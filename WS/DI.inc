{ The contents of this file are subject to the Mozilla Public License
  Version 1.1 (the "License"); you may not use this file except in
  compliance with the License. You may obtain a copy of the License at
  http://www.mozilla.org/MPL/

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations
  under the License.

  The Original Code is DI.inc.

  The Initial Developer of the Original Code is Ralf Junker <delphi@zeitungsjunge.de>.

  All Rights Reserved. }

{ ---------------------------------------------------------------------------- }

{$DEFINE DICheckFree}// Default: On
{ If DICheckFree is defined, objects keep track if they were freed before the
  application exits. Disabeling DICheckFree will generate smaller and faster
  code. You need the DIContainers Library if you want to enable this option. }

{$DEFINE DIRangeChecking}// Default: On
{ If DIRangeChecking is defined, code operations will check for ranges
  and result in error messages in case of violations. Disabeling DIRangeChecking
  will generate faster and smaller code.}

{ ---------------------------------------------------------------------------- }
{ Compiler Settings                                                            }
{ ---------------------------------------------------------------------------- }

{$A+}
(* The $A directive controls alignment of fields in record types.

   In the {$A+} state, fields in record types that are declared without the
   packed modifier are aligned. In the {$A-} state, fields in record types
   are never aligned. Record type field alignment is described in the Object
   Pascal Language Guide.

   Regardless of the state of the $A directive, variables and typed constants
   are always aligned for optimal access. In the {$A+} state, execution
   will be faster. *)

{$B-}
(* The $B directive switches between the two different models of code
   generation for the and and or Boolean operators.

   In the {$B+} state, the compiler generates code for complete Boolean
   expression evaluation. This means that every operand of a Boolean
   expression built from the and and or operators is guaranteed to be
   evaluated, even when the result of the entire expression is already known.

   In the {$B-} state, the compiler generates code for short-circuit Boolean
   expression evaluation, which means that evaluation stops as soon as the
   result of the entire expression becomes evident in left to right order
   of evaluation. *)

{$H+}
(* The $H directive controls the meaning of the reserved word string when
   used alone in a type declaration. The generic type string can represent
   either a long, dynamically-allocated string (the fundamental type AnsiString)
   or a short, statically-allocated string (the fundamental type ShortString).

   By default {$H+}, Delphi defines the generic string type to be the long
   AnsiString. All components in the Visual Component Library are compiled
   in this state. If you write components, they should also use long strings,
   as should any code that receives data from VCL string-type properties.

   The {$H-} state is mostly useful for using code from versions of Object
   Pascal that used short strings by default. You can locally override the
   meaning of string-type definitions to ensure generation of short strings.
   You can also change declarations of short string types to string[255] or
   ShortString, which are unambiguous and independent of the $H setting. *)

{$J-}
(* The $J directive controls whether typed constants can be modified or not.
   In the {$J+} state, typed constants can be modified, and are in essence
   initialized variables. In the {$J-} state, typed constants are truly
   constant, and any attempt to modify a typed constant causes the compiler
   to report an error. *)

{$T+}
(* The $T directive controls the types of pointer values generated by the
   @ operator and the compatibility of pointer types.

   In the {$T-} state, the result of the @ operator is always an untyped
   pointer (Pointer) that is compatible with all other pointer types.
   When @ is applied to a variable reference in the {$T+} state, the result
   is a typed pointer that is compatible only with Pointer and with other
   pointers to the type of the variable. *)

{$X+}
(* The $X directive enables or disables Delphi's extended syntax. *)

{ ---------------------------------------------------------------------------- }
{ Version Information - Do not change.                                         }
{ ---------------------------------------------------------------------------- }

{$IFDEF VER140}
{$DEFINE DELPHI_6}
{$DEFINE DELPHI_6+}
{$DEFINE DELPHI_5+}
{$DEFINE DELPHI_4+}
{$DEFINE DELPHI_3+}
{$DEFINE DELPHI_2+}
{$DEFINE DELPHI_1+}
{$ENDIF}

{$IFDEF VER130}
{$DEFINE DELPHI_5}
{$DEFINE DELPHI_5+}
{$DEFINE DELPHI_4+}
{$DEFINE DELPHI_3+}
{$DEFINE DELPHI_2+}
{$DEFINE DELPHI_1+}
{$ENDIF}

{$IFDEF VER120}
{$DEFINE DELPHI_4}
{$DEFINE DELPHI_4+}
{$DEFINE DELPHI_3+}
{$DEFINE DELPHI_2+}
{$DEFINE DELPHI_1+}
{$ENDIF}

{$IFDEF VER100}
{$DEFINE DELPHI_3}
{$DEFINE DELPHI_3+}
{$DEFINE DELPHI_2+}
{$DEFINE DELPHI_1+}
{$ENDIF}

{$IFDEF VER90}
{$DEFINE DELPHI_2}
{$DEFINE DELPHI_2+}
{$DEFINE DELPHI_1+}
{$ENDIF}

{$IFDEF VER80}
{$DEFINE DELPHI_1}
{$DEFINE DELPHI_1+}
{$ENDIF}

