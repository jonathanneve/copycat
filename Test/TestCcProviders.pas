unit TestCcProviders;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, CcProviders, Classes, Sysutils, DB;
type
  // Each TCcConnection descendant test case must define a descendant of
  // TestTCcConnection to test against a concrete connection

  TCcRecordCountTest = (rcZero, rcZeroOrOne, rcExactlyOne, rcAtLeastOne, rcAny);

{  // Test methods for class TCcSqlParser

  TestTCcSqlParser = class(TTestCase)
  strict private
    FCcSqlParser: TCcSqlParser;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestParse;
  end;
  // Test methods for class TCcQuery

  TestTCcQuery = class(TTestCase)
  strict private
    FCcQuery: TCcQuery;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestClose;
    procedure TestNext;
    procedure TestPrepare;
    procedure TestUnPrepare;
    procedure TestExec;
    procedure TestMacroExists;
    procedure TestFindMacro;
    procedure TestParamExists;
    procedure TestFindParam;
    procedure TestFieldExists;
    procedure TestFindField;
  end;}
  // Test methods for class TCcConnection

  TestTCcConnection = class(TTestCase)
  protected
    procedure TestConnection(conn: TCcConnection);
    procedure ConfigDB(conn: TCcConnection);
  private
    procedure CheckQuery(conn: TCcConnection; cQryName: String; paramNames: array of String;
      paramTypes: array of TFieldType; paramValues: array of Variant;
      fieldNames: array of String; fieldTypes: array of TFieldType;
      recCount: TCcRecordCountTest);
    procedure DoCheckQuery(qry: TCcQuery; paramNames: array of String;
      paramTypes: array of TFieldType; paramValues: array of Variant;
      fieldNames: array of String; fieldTypes: array of TFieldType;
      recCount: TCcRecordCountTest);
  end;

{  // Test methods for class TCcDBAdaptor
  TestTCcDBAdaptor = class(TTestCase)
  strict private
    FCcDBAdaptor: TCcDBAdaptor;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCheckCustomMetadata;
    procedure TestDeclareField;
    procedure TestFieldExists;
    procedure TestTableExists;
    procedure TestProcedureExists;
    procedure TestTriggerExists;
    procedure TestGenDeclared;
    procedure TestDeclareGenerator;
    procedure TestCreateProcedures;
    procedure TestRemoveTriggers;
    procedure TestGenerateTriggers;
    procedure TestGenerateProcedure;
    procedure TestGetProcGenerator;
    procedure TestGetGenerator;
    procedure TestGetProcParams;
    procedure TestConvertValue;
  end;}

implementation

uses
  CcConf, Forms;
  
const
  TestData: String = 'AZFE a"é)à0ç*ùm:és???¶???&?ezfß!Ó%????';

{
procedure TestTCcSqlParser.SetUp;
begin
  FCcSqlParser := TCcSqlParser.Create;
end;

procedure TestTCcSqlParser.TearDown;
begin
  FCcSqlParser.Free;
  FCcSqlParser := nil;
end;

procedure TestTCcSqlParser.TestParse;
var
  SQLText: string;
begin
  // TODO: Setup method call parameters
  FCcSqlParser.Parse(SQLText);
  // TODO: Validate method results
end;

procedure TestTCcQuery.SetUp;
begin
  FCcQuery := TCcQuery.Create;
end;

procedure TestTCcQuery.TearDown;
begin
  FCcQuery.Free;
  FCcQuery := nil;
end;

procedure TestTCcQuery.TestClose;
begin
  FCcQuery.Close;
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestNext;
begin
  FCcQuery.Next;
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestPrepare;
begin
  FCcQuery.Prepare;
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestUnPrepare;
begin
  FCcQuery.UnPrepare;
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestExec;
begin
  FCcQuery.Exec;
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestMacroExists;
var
  ReturnValue: Boolean;
  MacroName: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FCcQuery.MacroExists(MacroName);
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestFindMacro;
var
  ReturnValue: TCcMacro;
  MacroName: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FCcQuery.FindMacro(MacroName);
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestParamExists;
var
  ReturnValue: Boolean;
  ParamName: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FCcQuery.ParamExists(ParamName);
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestFindParam;
var
  ReturnValue: TCcField;
  Param: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FCcQuery.FindParam(Param);
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestFieldExists;
var
  ReturnValue: Boolean;
  FieldName: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FCcQuery.FieldExists(FieldName);
  // TODO: Validate method results
end;

procedure TestTCcQuery.TestFindField;
var
  ReturnValue: TCcField;
  FieldName: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FCcQuery.FindField(FieldName);
  // TODO: Validate method results
end;}


procedure TestTCcConnection.CheckQuery(conn: TCcConnection; cQryName: String; paramNames : array of String;
  paramTypes: array of TFieldType; paramValues: array of Variant; fieldNames : array of String;
  fieldTypes: array of TFieldType; recCount: TCcRecordCountTest);
begin
  DoCheckQuery(conn.SelectQuery[cQryName], paramNames, paramTypes, paramValues, fieldNames, fieldTypes, recCount);
end;

procedure TestTCcConnection.ConfigDB(conn: TCcConnection);
var
  config: TCcConfig;
begin
  //Connect using TCcConfig in order to create necessary meta-data
  config := TCcConfig.Create(Application);
  try
    config.Connection := conn;
    config.Connect;
    config.Disconnect;
  finally
    config.Free;
  end;
end;

procedure TestTCcConnection.DoCheckQuery(qry :TCcQuery; paramNames : array of String;
  paramTypes: array of TFieldType; paramValues: array of Variant; fieldNames : array of String;
  fieldTypes: array of TFieldType; recCount: TCcRecordCountTest);
var
  i: Integer;
  cContext: String;
  ParamType: TFieldType;
  FieldType: TFieldType;
begin
  if High(fieldNames) <> High(fieldTypes) then
    raise Exception.Create('Field names and field types must have same number of elements!');
  if High(paramNames) <> High(paramTypes) then
    raise Exception.Create('Param names and param types must have same number of elements!');

  cContext := 'CopyCat query test failed!'#13#10'Query: ' + qry.Name;
  cContext := cContext + ''#13#10'Fields: ';
  for i := 0 to High(fieldNames) do
    cContext := cContext + fieldNames[i] + '(' + IntToStr(Integer(fieldTypes[i])) + '); ';
  cContext := cContext + ''#13#10'Params: ';
  for i := 0 to High(paramNames) do
    cContext := cContext + paramNames[i] + '(' + IntToStr(Integer(paramTypes[i])) + '); ';
  cContext := cContext + ''#13#10'Expected record count: ';
  if recCount = rcZero then
    cContext := cContext + '0'
  else if recCount = rcZeroOrOne then
    cContext := cContext + '0 or 1'
  else if recCount = rcExactlyOne then
    cContext := cContext + '1'
  else if recCount = rcAtLeastOne then
    cContext := cContext + '>=1'
  else if recCount = rcAny then
    cContext := cContext + 'any';

  cContext := cContext + #13#10#13#10;

  with qry do begin
    if High(paramNames) = -1 then
      CheckEquals(ParamCount, 0, cContext + 'Invalid param count ' + IntToStr(ParamCount))
    else
      for i := 0 to High(paramNames)  do begin
        Check(ParamExists(paramNames[i]), cContext + 'Undefined parameter: ' + paramNames[i]);
        ParamType := Param[paramNames[i]].DataType;
        if ParamType = ftWideString then
          ParamType := ftString;
        Check((ParamType = ftUnknown) or (ParamType = paramTypes[i]), cContext + 'Param ' + paramNames[i] + ' is of wrong datatype (' + IntToStr(Integer(ParamType)) + ')');
        Param[paramNames[i]].Value := paramValues[i];
      end;

    Exec;

    if High(fieldNames) = -1 then
      CheckEquals(FieldCount,  0, cContext + 'Invalid field count ' + IntToStr(FieldCount))
    else
      for i := 0 to High(fieldNames)  do begin
        Check(FieldExists(fieldNames[i]), cContext + 'Undefined field: ' + fieldNames[i]);
        FieldType := Field[fieldNames[i]].DataType;
        if FieldType = ftWideString then
          FieldType := ftString;
        Check(FieldType = fieldTypes[i], cContext + 'Field ' + fieldNames[i] + ' is of wrong datatype (' + IntToStr(Integer(Field[fieldNames[i]].DataType)) + ')');
      end;

    if recCount = rcZero then
      CheckEquals(RecordCount, 0, cContext + 'Incorrect RecordCount = ' + IntToStr(RecordCount))
    else if recCount = rcZeroOrOne then
      Check((RecordCount = 0) or (RecordCount = 1), cContext + 'Incorrect RecordCount = ' + IntToStr(RecordCount))
    else if recCount = rcExactlyOne then
      CheckEquals(RecordCount, 1, cContext + 'Incorrect RecordCount = ' + IntToStr(RecordCount))
    else if recCount = rcAtLeastOne then
      Check(RecordCount >=1, cContext + 'Incorrect RecordCount = ' + IntToStr(RecordCount));
    Close;
  end;
end;

procedure TestTCcConnection.TestConnection(conn: TCcConnection);
var
  nTest: Integer;
  q: TCcQuery;
begin
  with conn do begin
    Connect;

    SelectQuery['recordCountTest'].SQL.Text := 'select table_name from rpl$tables where 1=0';
    CheckQuery(conn, 'recordCountTest', [], [], [], ['table_name'], [ftString], rcZero);

    SelectQuery['recordCountTest2'].SQL.Text := 'select table_name from rpl$tables';
    CheckQuery(conn, 'recordCountTest2', [], [], [], ['table_name'], [ftString], rcAtLeastOne);

    with SelectQuery['paramTest'] do begin
      Close;
      SQL.Text := 'select * from rpl$log where login = :login and operation_date = :op_date';
      Prepare;

      CheckEquals(ParamCount, 2);
      Check(Param['login'].DataType = ftString);
      Check(Param['op_date'].DataType in [ftDate, ftTime, ftDateTime]);

      Param['login'].Value := TestData;
      CheckEquals(Param['login'].Value, TestData);
      UnPrepare;
    end;

    with SelectQuery['nullTest'] do begin
      Close;
      SQL.Text := 'select '''' as null_string, null as null_value from rpl$tables';
      Exec;

      Check(Field['null_string'].Value = '', 'Null strings are received incorrectly');
      Check(not Field['null_string'].IsNull, 'Null strings are received incorrectly');
      Check(Field['null_value'].IsNull, 'Null values are received incorrectly');

      q := UpdateQuery['updateNullTest'];
      q.Close;
      q.SQL.Text := 'insert into rpl$users (login, libelle, condition_value) values (:login, :libelle, :condition_value)';
      q.Param['login'].AsString := '!!!!TEST!!!!';
      q.Param['libelle'].AsString := '';
      q.Param['condition_value'].Clear;

      try
        q.Exec;

        Close;
        SQL.Text := 'select libelle, condition_value from rpl$users where login = ''!!!!TEST!!!!''';
        Exec;

        Check(Field['libelle'].Value = '', 'Null strings are sent incorrectly');
        Check(not Field['libelle'].IsNull, 'Null strings are sent incorrectly');
        Check(Field['condition_value'].IsNull, 'Null values are sent incorrectly');
      finally
        conn.RollbackRetaining;
      end;
    end;



    nTest := Gen_ID('GEN_RPL$CONFLICTS', 1);// 'select table_name from rpl$tables where 1=0';

    Disconnect;
  end;
end;

initialization
  // Register any test cases with the test runner
//  RegisterTest(TestTCcSqlParser.Suite);
//  RegisterTest(TestTCcQuery.Suite);
  RegisterTest(TestTCcConnection.Suite);
//  RegisterTest(TestTCcDBAdaptor.Suite);
end.

