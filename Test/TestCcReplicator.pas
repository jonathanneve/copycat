unit TestCcReplicator;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, ExtCtrls, CcConfStorage, CCat, Classes, SyncObjs, DB, CcProviders, CcMemDS,
  CcKeys, SysUtils, CcReplicator, CcConf;
type
  // Test methods for class TCcReplicator
  
  // Each TCcConnection descendant test case must define a descendant of
  // this class to test against a concrete connection

  TestTCcReplicator = class(TTestCase)
  private
    procedure CheckBounce;
    function GetData(conn: TCcConnection; nCode: Variant): String;
    procedure InsertData(conn: TCcConnection; nCode: Variant; cData: String);
    function GetRecordCount(conn: TCcConnection; cTableName: String): Integer;
    procedure SetupTests(conn: TCcConnection);
    procedure CleanupTests(conn: TCcConnection);
    procedure TestBasicReplication;
    procedure TestConflicts;
    procedure DropTestTable(conn: TCcConnection);
    procedure TestConditions;
  protected
    FCcReplicator: TCcReplicator;
    FCcConfig: TCcConfig;
//    procedure SetupNodes;virtual;abstract;
    procedure InitReplication;
    procedure CleanupReplication;
    procedure TestReplication;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  end;

implementation

uses
  Forms;

const
  cLocalData: String = 'LOCAL DATA!';
  cNewLocalData: String = 'NEW LOCAL DATA!';
  cRemoteData : String = 'REMOTE DATA!';
  cNewRemoteData : String = 'NEW REMOTE DATA!';

procedure TestTCcReplicator.CleanupReplication;
begin
  CleanupTests(FCcReplicator.LocalDB);
  CleanupTests(FCcReplicator.RemoteDB);
  FCcReplicator.Disconnect;
end;

procedure TestTCcReplicator.CleanupTests;
begin
  FCcConfig.Connection := conn;
  FCcConfig.Disconnect;
  FCcConfig.Connect;
  FCcConfig.RemoveTriggers('RPL$TESTS');
  conn.Commit;
  conn.StartTransaction;

  //Drop test table RPL$TESTS
  if conn.DBAdaptor.TableExists('RPL$TESTS') then
    with conn.UpdateQuery['TestTCcReplicator_DROPRPLTESTS'] do begin
      Close;
      SQL.Text := 'delete from RPL$TESTS';
      Exec;
    end;

  //Empty RPL$LOG
  if conn.DBAdaptor.TableExists('RPL$LOG') then
    with conn.UpdateQuery['TestTCcReplicator_EmptyRPLLOG'] do begin
      Close;
      SQL.Text := 'delete from RPL$LOG';
      Exec;
    end;

  //Empty RPL$USERS
  if conn.DBAdaptor.TableExists('RPL$USERS') then
    with conn.UpdateQuery['TestTCcReplicator_EmptyRPLUSERS'] do begin
      Close;
      SQL.Text := 'delete from RPL$USERS';
      Exec;
    end;

  //Empty RPL$CONFLICTS
  if conn.DBAdaptor.TableExists('RPL$CONFLICTS') then
    with conn.UpdateQuery['TestTCcReplicator_EmptyRPLConflicts'] do begin
      Close;
      SQL.Text := 'delete from rpl$conflicts';
      Exec;
    end;
  conn.Commit;
end;

procedure TestTCcReplicator.SetUp;
begin
  FCcReplicator := TCcReplicator.Create(Application);
  FCcReplicator.KeepConnection := True;
  FCcReplicator.HarmonizeFields := True;
  FCcReplicator.CommitOnFinished := ctRetaining;
  FCcConfig := TCcConfig.Create(Application);

  //Descendants must setup the Nodes properties
//  SetupNodes;

  FCcReplicator.LocalNode.Name := 'Local';
  FCcReplicator.RemoteNode.Name := 'Remote';
end;

procedure TestTCcReplicator.InitReplication;
begin
  FCcReplicator.LocalNode.Connection.Connect;
  FCcReplicator.RemoteNode.Connection.Connect;

  //Cleanup database in case a previous test had left it messy
  CleanupTests(FCcReplicator.LocalNode.Connection);
  CleanupTests(FCcReplicator.RemoteNode.Connection);

  //Setup database for tests
  SetupTests(FCcReplicator.LocalNode.Connection);
  SetupTests(FCcReplicator.RemoteNode.Connection);
end;

procedure TestTCcReplicator.SetupTests(conn: TCcConnection);
var
  cNodeName: String;
begin
  //Create test table RPL$TESTS
  if not conn.DBAdaptor.TableExists('RPL$TESTS') then
    conn.ExecQuery('create table rpl$tests (code integer not null primary key, ' +
                   'data varchar(50))');
  if not conn.DBAdaptor.TableExists('RPL$TESTS2') then
    conn.ExecQuery('create table rpl$tests2 (code integer not null primary key, ' +
                   'data varchar(50), node varchar(10))');
  if not conn.DBAdaptor.TableExists('RPL$TESTS3') then
    conn.ExecQuery('create table rpl$tests3 (code integer not null primary key, ' +
                   'data varchar(50))');

  conn.Commit;

  //Generate triggers for table
  FCcConfig.Connection := conn;
  FCcConfig.Connect;

  conn.ExecQuery('update rpl$tables set condition_field = ''NODE'' where table_name = ''RPL$TESTS2''');
  conn.ExecQuery('update rpl$tables set condition = ''(u.condition_value = ''CONDITION_TEST'')'' where table_name = ''RPL$TESTS3''');

  FCcConfig.GenerateTriggers('RPL$TESTS');
  FCcConfig.GenerateTriggers('RPL$TESTS2');
  FCcConfig.GenerateTriggers('RPL$TESTS3');
  FCcConfig.Disconnect;

  conn.Connect;
  conn.StartTransaction;
  //Fill RPL$USERS adequately
  if conn = FCcReplicator.LocalNode.Connection then
    cNodeName := FCcReplicator.RemoteNode.Name
  else
    cNodeName := FCcReplicator.LocalNode.Name;

  conn.ExecQuery('insert into rpl$users (login, condition_value) values (' + QuotedStr(cNodeName) + ', ''TEST'')');
  conn.ExecQuery('insert into rpl$users (login, condition_value) values (''CONDITION_FIELD_TEST'', ''CONDITION_FIELD_TEST'')');
  conn.ExecQuery('insert into rpl$users (login, condition_value) values (''CONDITION_TEST'', ''CONDITION_TEST'')');

  if not FCcReplicator.LocalDB.DBAdaptor.GenDeclared('gen_rpl$tests') then
    FCcReplicator.LocalDB.DBAdaptor.DeclareGenerator('gen_rpl$tests');
end;

procedure TestTCcReplicator.TearDown;
begin
  try
    if FCcReplicator.LocalDB.Connected then 
      CleanupTests(FCcReplicator.LocalDB);
    if FCcReplicator.RemoteDB.Connected then
      CleanupTests(FCcReplicator.RemoteDB);

//    DropTestTable(FCcReplicator.LocalDB);
//    DropTestTable(FCcReplicator.RemoteDB);

    FCcReplicator.Disconnect;
  finally
    FCcReplicator.Free;
    FCcReplicator := nil;
  end;
end;

procedure TestTCcReplicator.DropTestTable(conn: TCcConnection);
begin
  conn.Commit;
  conn.StartTransaction;
  if conn.DBAdaptor.TableExists('RPL$TESTS') then
    with conn.UpdateQuery['TestTCcReplicator_DROPRPLTESTS'] do begin
      Close;
      SQL.Text := 'drop table rpl$tests';
      Exec;
    end;
end;

procedure TestTCcReplicator.TestBasicReplication;
var
  nLocalCode: Variant;
  nRemoteCode: Variant;
  localGUID, remoteGUID: TGUID;
begin
  nLocalCode := FCcReplicator.LocalNode.Connection.Gen_Id('gen_rpl$tests', 1);
  nRemoteCode := FCcReplicator.LocalNode.Connection.Gen_Id('gen_rpl$tests', 1);
//  CreateGUID(localGUID);
//  CreateGUID(remoteGUID);
//  nLocalCode := GUIDToString(localGUID);
//  nRemoteCode := GUIDToString(remoteGUID);

  //Check INSERT
  InsertData(FCcReplicator.LocalNode.Connection, nLocalCode, cLocalData);
  InsertData(FCcReplicator.RemoteNode.Connection, nRemoteCode, cRemoteData);

//  FCcReplicator.RemoteNode.Connection.ReplicatingNode;
//  FCcReplicator.LocalNode.Connection.ReplicatingNode;

  FCcReplicator.Disconnect;
  FCcReplicator.Connect;
  FCcReplicator.Replicate;

  //Check that the remote data is in the local database and vice versa
  CheckEquals(cRemoteData, GetData(FCcReplicator.LocalNode.Connection, nRemoteCode));
  CheckEquals(cLocalData, GetData(FCcReplicator.RemoteNode.Connection, nLocalCode));

  //Check UPDATE
{  UpdateData(FCcReplicator.LocalNode.Connection, nLocalCode, cNewLocalData);
  UpdateData(FCcReplicator.RemoteNode.Connection, nRemoteCode, cNewRemoteData);

  FCcReplicator.Replicate;

  //Check that the remote data is in the local database and vice versa
  CheckEquals(cRemoteData, GetData(FCcReplicator.LocalNode.Connection, nRemoteCode));
  CheckEquals(cLocalData, GetData(FCcReplicator.RemoteNode.Connection, nLocalCode));

  //Check DELETE
  DeleteData(FCcReplicator.LocalNode.Connection, nLocalCode);
  DeleteData(FCcReplicator.RemoteNode.Connection, nRemoteCode);

  FCcReplicator.Replicate;

  FCcReplicator.LocalNode.Connection.CommitRetaining;
  FCcReplicator.RemoteNode.Connection.CommitRetaining;

  //Check that the remote data is in the local database and vice versa
  CheckEquals(cRemoteData, GetData(FCcReplicator.LocalNode.Connection, nRemoteCode));
  CheckEquals(cLocalData, GetData(FCcReplicator.RemoteNode.Connection, nLocalCode));     }

  CheckBounce;
end;

procedure TestTCcReplicator.CheckBounce;
begin
  //Make sure it doesn't bounce
  CheckEquals(0, GetRecordCount(FCcReplicator.RemoteNode.Connection, 'rpl$log'));
  CheckEquals(0, GetRecordCount(FCcReplicator.LocalNode.Connection, 'rpl$log'));
end;

procedure TestTCcReplicator.TestConflicts;
var
  nCode: Integer;
  localGUID: TGUID;
begin
  nCode := FCcReplicator.LocalNode.Connection.Gen_Id('gen_rpl$tests', 1);
//  CreateGUID(localGUID);
//  nCode := GUIDToString(localGUID);

  InsertData(FCcReplicator.LocalNode.Connection, nCode, cLocalData);
  InsertData(FCcReplicator.RemoteNode.Connection, nCode, cRemoteData);

  FCcReplicator.Disconnect;
  FCcReplicator.Connect;
  FCcReplicator.Replicate;

  FCcReplicator.LocalDB.CommitRetaining;
  FCcReplicator.RemoteDB.CommitRetaining;

  //Make sure the conflict was logged correctly
  CheckEquals(1, GetRecordCount(FCcReplicator.LocalNode.Connection, 'rpl$conflicts'));
  CheckEquals(1, GetRecordCount(FCcReplicator.RemoteNode.Connection, 'rpl$conflicts'));

  //Check that the data hasn't been replicated
  CheckEquals(cRemoteData, GetData(FCcReplicator.RemoteNode.Connection, nCode));
  CheckEquals(cLocalData, GetData(FCcReplicator.LocalNode.Connection, nCode));

  with FCcReplicator.LocalNode.Connection.UpdateQuery['TestTCcReplicator_ResolveConflict'] do begin
    Close;
    SQL.Text := 'update rpl$conflicts set chosen_user = :chosen_user where table_name = ''RPL$TESTS'' and primary_key_values = :primary_key_values';
    Param['primary_key_values'].Value := '''' + IntToStr(nCode) + ''';';
    Param['chosen_user'].Value := FCcReplicator.LocalNode.Name;
    Exec;
  end;

  FCcReplicator.LocalDB.CommitRetaining;
  FCcReplicator.RemoteDB.CommitRetaining;

  FCcReplicator.Replicate;

  FCcReplicator.LocalDB.CommitRetaining;
  FCcReplicator.RemoteDB.CommitRetaining;

  //Make sure there's no more trace of the conflict
  CheckEquals(0, GetRecordCount(FCcReplicator.LocalNode.Connection, 'rpl$conflicts'));
  CheckEquals(0, GetRecordCount(FCcReplicator.RemoteNode.Connection, 'rpl$conflicts'));

  //Check that the local data has been replicated to both sides
  CheckEquals(cLocalData, GetData(FCcReplicator.LocalNode.Connection, nCode));
  CheckEquals(cLocalData, GetData(FCcReplicator.RemoteNode.Connection, nCode));

  CheckBounce;
end;

procedure TestTCcReplicator.TestReplication;
var
  slVersions: TStringList;
  I: Integer;
begin
//  slVersions := TStringList.Create;
//  FCcReplicator.LocalDB.DatabaseVersions(slVersions);
//  for I := 0 to FCcReplicator.LocalDB. - 1 do

  InitReplication;
  TestBasicReplication;
  CleanupReplication;

  InitReplication;
  TestConflicts;
  CleanupReplication;

  InitReplication;
  TestConditions;
  CleanupReplication;
end;

procedure TestTCcReplicator.TestConditions;
var
  nCode: Integer;
begin
  nCode := FCcReplicator.LocalNode.Connection.Gen_Id('gen_rpl$tests', 1);
  //Test condition_field
//  FCcReplicator.LocalDB.ExecQuery('insert into rpl$tests2 (code, node) values (' + ')';
end;

procedure TestTCcReplicator.InsertData(conn :TCcConnection; nCode: Variant; cData: String);
begin
  with conn.UpdateQuery['TestTCcReplicator_InsertData'] do begin
    Close;
    SQL.Text := 'insert into rpl$tests(code, data) values (:code, :data)';
    Param['code'].Value := nCode;
    Param['data'].Value := cData;
    Exec;
  end;
end;

function TestTCcReplicator.GetData(conn :TCcConnection; nCode: Variant): String;
begin
  with conn.SelectQuery['TestTCcReplicator_GetData'] do begin
    Close;
    SQL.Text := 'select data from rpl$tests where code = :code';
    Param['code'].Value := nCode;
    Exec;
    CheckEquals(RecordCount, 1);
    Result := Field['data'].AsString;
  end;
end;

function TestTCcReplicator.GetRecordCount(conn: TCcConnection; cTableName: String): Integer;
var
  q: TCcQuery;
begin
  q := TCcQuery.Create(conn, '', true);
  try
    q.Close;
    q.SQL.Text := 'select count(*) as rec_count from ' + cTableName;
    q.Exec;
    Result := q.Field['rec_count'].Value;
  finally
    q.Free;
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTCcReplicator.Suite);
end.

